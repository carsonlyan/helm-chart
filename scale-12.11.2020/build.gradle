def helmRelease = 'scale'

task pushAll(type: Task) {
    dependsOn(
        ':scale-admin:dockerPublishRegistry',
        ':scale-collector:dockerPublishRegistry',
        ':scale-cluster-manager:backend:dockerPublishRegistry',
        ':scale-demodata-adams:dockerPublishRegistry',
        ':scale-demodata-vtd:dockerPublishRegistry',
        ':scale-git:dockerPublishRegistry',
        ':scale-jenkins:dockerPublishRegistry',
        ':scale-market:dockerPublishRegistry',
        ':scale-services:dockerPublishRegistry',
        ':scale-spark:dockerPublishRegistry',
        ':scale-worker:dockerPublishRegistry', 
        ':scale-worker-adams:dockerPublishRegistry', 
        ':scale-worker-applicator:dockerPublishRegistry', 
        ':scale-worker-downloader:dockerPublishRegistry', 
        ':scale-worker-sampler:dockerPublishRegistry', 
        ':scale-worker-vtd-processor:dockerPublishRegistry', 
        ':scale-worker-vtd-sidecar:dockerPublishRegistry',
        ':scale-worker-vtd-simulator:dockerPublishRegistry',
        ':scale-worker-vtd-simulator-gpu:dockerPublishRegistry',
    )
}

task minikubeDown(type: Exec) {
    group = "Scale"
    description = "Delete current Minikube cluster"
 
    commandLine 'minikube', 'delete'
}

task minikubeStart(type: Exec) {
    group = "Scale"
    description = "Enable Minikube Ingress"
    
    mustRunAfter minikubeDown

    commandLine 'minikube', 'start', '--insecure-registry', '"10.0.0.0/24"'
}

task minikubeUp(type: Exec) {
    group = "Scale"
    description = "Startup a new Minikube"
 
    dependsOn minikubeStart

    commandLine 'minikube', 'addons', 'enable', 'ingress'
}

def chart = new org.yaml.snakeyaml.Yaml().load( new File("${projectDir}/src/main/helm/Chart.yaml").newInputStream())

project.ext {
  scaleChartName = chart.name
  scaleChartVersion = chart.version
}

task helmPrepareChart(type: Exec){
    group = "Scale"
    description = "Prepare VTD Scale charts for OCI registry"
    environment 'HELM_EXPERIMENTAL_OCI', '1'
    commandLine 'helm', 'chart', 'save', './src/main/helm', "${helmChartRegistry}/${project.scaleChartName}:${project.scaleChartVersion}"
    doFirst {
      logger.info("Executing command ${commandLine}")
    }
}

task helmPublishChart(type: Exec){
    group = "Scale"
    description = "Publish VTD Scale charts to OCI registry"
    environment 'HELM_EXPERIMENTAL_OCI', '1'
    commandLine 'helm', 'chart', 'push', "${helmChartRegistry}/${project.scaleChartName}:${project.scaleChartVersion}"
    doFirst {
      logger.info("Executing command ${commandLine}")
    }
}

task helmRemoveChart(type: Exec){
    group = "Scale"
    description = "Remove saved VTD Scale charts "
    environment 'HELM_EXPERIMENTAL_OCI', '1'
    commandLine 'helm', 'chart', 'remove', "${helmChartRegistry}/${project.scaleChartName}:${project.scaleChartVersion}"
    doFirst {
      logger.info("Executing command ${commandLine}")
    }
}

task activateKubectlCluster(type: Exec) {
    commandLine 'kubectl', 'config', 'use-context', localKubernetesContextName
}

task helmDelete(type: Exec) {
    dependsOn activateKubectlCluster
    commandLine 'helm', '-n', kubernetesNamespace, 'uninstall', helmRelease
    ignoreExitValue = true
}

task kubectlDelete(type: Exec) {
    dependsOn activateKubectlCluster
    commandLine 'kubectl', '-n', kubernetesNamespace, 'delete', 'statefulsets,daemonsets,replicasets,services,deployments,pods,rc,ingresses,configmaps', '--all', '--grace-period=0', '--force'
}

task down(type: Task) {
    group = "Scale"
    description = "Un-Deploy Scale from local K8S"

    dependsOn helmDelete, kubectlDelete
}

task deleteVolumes(type: Exec) {
    commandLine 'kubectl', '-n', kubernetesNamespace, 'delete', 'pv,pvc', '--all', '--grace-period=0', '--force'
    dependsOn down, activateKubectlCluster
}

task addChartRepos(type: Exec) {
    commandLine 'helm', 'repo', 'add', 'bitnami', 'https://charts.bitnami.com/bitnami'
}

task addChartDependencies(type: Exec) {
    dependsOn addChartRepos
    commandLine 'helm', 'dependency', 'update'
    workingDir './src/main/helm'
}

task upNoBuild(type: Exec) {
    group = "Scale"
    description = "Deploy Scale to local K8S"
 
    dependsOn down, activateKubectlCluster, addChartDependencies
    mustRunAfter pushAll

    commandLine 'helm', '-n', kubernetesNamespace, 'install', helmRelease, './src/main/helm', '--set', "imageTag=${scaleGitVersion}"
}

task up() {
    group = "Scale"
    description = "Deploy Scale to local K8S"
 
    dependsOn pushAll, upNoBuild
}

task upgrade(type: Exec) {
    group = "Scale"
    description = "Upgarde Scale to local K8S"
 
    dependsOn pushAll, activateKubectlCluster, addChartDependencies

    commandLine 'helm', '-n', kubernetesNamespace, 'upgrade', helmRelease, './src/main/helm', '--set', "imageTag=${scaleGitVersion}"
}

def execOutput(cmd) {

    def out = new ByteArrayOutputStream()
    
    project.exec {
    
       commandLine = cmd
       
       standardOutput = out
    }
    
    return out.toString().trim()
}

def retry(int maxRetries = 9, long sleepTime = 1000, Closure errorHandler = {e -> println 'Command execution failed' }, Closure method) {

   int retries = 0
   
   while(retries++ < maxRetries) {
   
     try {
    
       def output = method.call()
       
       if (!output?.trim()) {
       
          logger.info("Command execution succeeded but returns empty string")

          throw new RuntimeException("Empty result")
       }
       
       return output
      
     } catch(e) {
    
       errorHandler.call(e)
      
       logger.info("Sleeping before retry ${sleepTime} ms")
       
       sleep(sleepTime)
       
       sleepTime *= 1.3
     }   
      
   }
  
   throw new RuntimeException("Retry execution failed")
}


def ingressHostname() {
  
    def cmd = ['kubectl', 'get', 'svc', '-n', kubernetesNamespace, 'ingress-nginx', '-o', "jsonpath={.status.loadBalancer.ingress[0].hostname}"]
    
    try {
     
       retry {
       
          return execOutput(cmd)
       }
       
    } catch(e) {
    
       logger.error('ERROR: Cannot extract ingress hostname. Please try again later or debug manually')
       
       throw e
    }
}

task createResourceRecordFile() {

    doLast {
       copy {
       
          from 'src/main/resources/templates'
    
          into "$buildDir"
    
          include 'recordset.json'

          def ingressHostname = ingressHostname()
          
          logger.info("Retrieved ingress hostname $ingressHostname")

          expand(clusterDomain: clusterDomain, ingressHostname: ingressHostname)
       }
    }
}

task updateResourceRecord(type: Exec) {

    dependsOn createResourceRecordFile
    
    commandLine 'aws', 'route53', 'change-resource-record-sets', '--hosted-zone-id', hostedZone, '--change-batch', "file://${buildDir}/recordset.json"
    
     doFirst {
     
        logger.info("Updating the DNS record set")
    
        logger.info("Executing command ${commandLine}")
        
        String recordJson = new File("${buildDir}/recordset.json").text
        
        logger.info("${buildDir}/recordset.json \n${recordJson}")
     }
}

task clean {
    doLast {
        delete buildDir
    }
}
